# 摄像机

[TOC]

![img](https://learnopengl-cn.github.io/img/01/09/camera_axes.png)



# 摄像机/观察空间 

## 1. 摄像机位置Position

摄像机的位置，可以看作世界空间中一个指向摄像机位置的向量

```c
glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
```

> Z 轴正向面对屏幕，希望摄像机前后移动，只需改变 z 



## 2. 摄像机方向 Direction

意思是：摄像机指向的方向

如摄像机指向场景原点，则**摄像机的指向向量 = 场景原点 - 摄像机位置向量**

已知摄像机指向 z轴负向，希望让`方向向量 Direction Vector`指向 z轴正向

变换做差顺序，即可得到一个**指向摄像机正z轴方向的向量**

> note-by-creagskin：摄像机视野的反方向，为摄像机的正z轴方向

```c++
glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);
glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);
```

> 方向向量 Direction Vector 命名并不确切，实际上的摄像机指向 cameraDirection，与以上代码得出的相反 **蓝色所示**

由此，得到摄像机方向，即摄像机i空间中正z轴方向向量 cameraDirection



## 3. 右轴 Right

右向量 Right Vector，代表摄像机空间的 x轴正方向（右手中指指向）

**右向量 = 摄像机空间中x轴正向**

如何得到右向量？

先定义一个`上向量 Up Vector`(0, 1, 0)，把上向量和方向向量叉乘，得出的向量会同时垂直于`上向量`和`右向量`

```c++
glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); 
glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));
```

向量1叉乘向量2，得出的向量方向为右手做握手动作时，大拇指方向

由此，得到右向量 cameraRight



## 4. 上轴

已有右轴（摄像机x轴正向）和摄像机方向（摄像机z轴正向），右向量叉乘些相机方向向量，得出正y轴向量

```c++
glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);
```



由此，一共得到

+ 摄像机的正z轴方向向量（摄像机的方向向量）
+ 摄像机的正x轴方向向量（右轴）
+ 摄像机的正y轴方向向量（上轴）

可以构造 LookAt 矩阵了



# Look At

<img src="https://www.qiniu.cregskin.com/image-20201020195015692.png" alt="image-20201020195015692" style="zoom:67%;" />

其中

+ R是右向量
+ U是上向量
+ D是方向向量
+ P是摄像机位置向量

注意，**位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。**

LookAt 矩阵作用是，作为观察矩阵，可以高效地把所有世界坐标变换到刚刚定义的观察空间



glm已经内置创建这个观察矩阵的方法

```c++
glm::mat4 view;
view = glm::lookAt(
          glm::vec3(0.0f, 0.0f, 3.0f), 
          glm::vec3(0.0f, 0.0f, 0.0f), 
          glm::vec3(0.0f, 1.0f, 0.0f)
);
```

提供的三个参数，分别是

+ 摄像机位置
+ 目标位置
+ 表示世界空间中上向量的向量（计算右轴时使用的那个上向量）



下面创建这样一个观察矩阵：

摄像机注视点始终保持在(0, 0, 0)，为摄像机位置规划一个圆形轨道，让摄像机在圆轨上移动

```c++
float radius = 10.0f; // 半径
float camX = sin(glfwGetTime()) * radius; // 摄像机位置 x轴坐标
float camZ = cos(glfwGetTime()) * radius; // 摄像机位置 z轴坐标
glm::mat4 view; // 定义观察矩阵，glm负责初始化为单位矩阵
view = glm::lookAt(
      glm::vec3(camX, 0.0, camZ), 
      glm::vec3(0.0, 0.0, 0.0),  
      glm::vec3(0.0, 1.0, 0.0)
);  // 创建一个观察矩阵
```

