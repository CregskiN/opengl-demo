

[TOC]

![img](https://learnopengl-cn.github.io/img/01/09/camera_axes.png)



# 摄像机/观察空间 

## 1. 摄像机位置Position

摄像机的位置，可以看作世界空间中一个指向摄像机位置的向量

```c
glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
```

> Z 轴正向面对屏幕，希望摄像机前后移动，只需改变 z 

> 摄像机在世界空间中的位置



## 2. 摄像机方向 Direction

意思是：摄像机指向的方向

如摄像机指向场景原点，则**摄像机的方向向量 = 场景原点 - 摄像机位置向量**

已知摄像机指向 z轴负向，希望让`方向向量 Direction Vector`指向 z轴正向

变换做差顺序，即可得到一个**指向摄像机正z轴方向的向量**

> note-by-creagskin：摄像机视野的反方向，为摄像机的正z轴方向

```c++
glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);
glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);
```

> 方向向量 Direction Vector 命名并不确切，实际上指向摄像机本身到目标位置的反方向

> 摄像机方向向量，指向摄像机空间中正z轴的反方向

![img](https://learnopengl-cn.github.io/img/01/09/camera_axes.png)



## 3. 右轴 Right

右向量 Right Vector，代表摄像机空间的 x轴 正方向（右手中指指向）

**右向量 = 摄像机空间中x轴正向**

如何得到右向量？

先定义一个`上向量 Up Vector`(0, 1, 0)，把上向量和方向向量叉乘，得出的向量会同时垂直于`上向量`和`右向量`

```c++
glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); 
glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));
```

向量1 叉乘 向量2，得出的向量方向为右手做握手动作时，大拇指方向



由此，得摄像机右轴 camera Right vector ，即摄像机x轴正方向



## 4. 上轴 UP

已有右轴（摄像机x轴正向）和摄像机方向（摄像机z轴正向），右向量叉乘些相机方向向量，得出正y轴向量

```c++
glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);
```

> glm::cross(vector A, vector B); 求向量 A B 的叉乘

由此，一共得到

+ 摄像机的正z轴方向向量（摄像机的方向向量）
+ 摄像机的正x轴方向向量（右轴）
+ 摄像机的正y轴方向向量（上轴）

可以构造 LookAt 矩阵了



# Look At

<img src="https://www.qiniu.cregskin.com/image-20201020195015692.png" alt="image-20201020195015692" style="zoom:67%;" />

其中

+ R是右向量
+ U是上向量
+ D是方向向量
+ P是摄像机位置向量

注意，**位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。**

LookAt 矩阵作用是，作为观察矩阵，可以高效地把所有世界坐标变换到刚刚定义的观察空间



glm已经内置创建这个观察矩阵的方法

```c++
glm::mat4 view;
view = glm::lookAt(
          glm::vec3(0.0f, 0.0f, 3.0f), 
          glm::vec3(0.0f, 0.0f, 0.0f), 
          glm::vec3(0.0f, 1.0f, 0.0f)
);
```

提供的三个参数，分别是

+ 摄像机位置向量，摄像机正x轴方向
+ 目标位置，摄像机方向向量，摄像机正z轴方向
+ 表示世界空间中上向量的向量（计算右轴时使用的那个上向量）



下面创建这样一个观察矩阵：

摄像机注视点始终保持在(0, 0, 0)，为摄像机位置规划一个圆形轨道，让摄像机在圆轨上移动

```c++
float radius = 10.0f; // 半径
float camX = sin(glfwGetTime()) * radius; // 摄像机位置向量的x轴坐标
float camZ = cos(glfwGetTime()) * radius; // 摄像机位置向量的 z轴坐标
glm::mat4 view; // 定义观察矩阵，glm负责初始化为单位矩阵
view = glm::lookAt(
      glm::vec3(camX, 0.0, camZ),  // eye 观察位置/摄像机位置
      glm::vec3(0.0, 0.0, 0.0),  // center 目标位置/摄像机方向向量/摄像机z轴正方向
      glm::vec3(0.0, 1.0, 0.0)
);  // 创建一个观察矩阵
```





# 自由移动

定义摄像机变量

```c++
glm::vec3 cameraPods = glm::vec3(0.0f, 0.0f, 3.0f); // 摄像机在世界空间中的位置
glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f); // 摄像机方向向量，摄像机正z轴的反方向
glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f); // 此处使用世界空间中y轴正向作为上向量
// 摄像机空间中：
// 正Z轴指向世界空间z轴正向
// 正x轴指向世界空间x轴正向
// 正y轴指向世界空间y轴正向
// 摄像机位置：
// 世界空间中(0, 0, 3)
```

生成 LookAt 变换

```c++
view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
// 摄像机位置
// 摄像机方向向量/目标位置/摄像机空间正z轴方向的反方向
// 世界空间中假设的上向量
```

响应键盘事件

```c++
void processInput(GLFWwindow *window) {
  float cameraSpeed = 0.05f; // adjust accordingly
  if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS){
		// 摄像机位置向量 = 摄像机位置向量 - 标量*摄像机方向向量
    //（摄像机方向向量与摄像机空间中正z轴反向，本例中还与摄像机位置向量反向）
    // 结果：摄像机朝向世界空间z轴负向，摄像机位置向量的z轴分量减小。以(0, 0, 3)为起点，往(0, 0, -∞)移动
    // 视觉上：摄像机向上移动
    cameraPos += cameraSpeed * cameraFront; 
  }
  if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS){
    // 摄像机位置向量 = 摄像机位置向量 + 标量*摄像机方向向量（本例中与摄像机位置向量反向）
    // 结果：摄像机朝向世界空间z轴负向，摄像机位置向量的z轴分量不断增大。以(0, 0, 3)为原点，往(0, 0, +∞)移动
    // 视觉上：摄像机向下移动
    cameraPos -= cameraSpeed * cameraFront;
  }
  if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS){
    // glm::cross(cameraFront, cameraUp) 
    // 摄像机方向向量 叉乘 世界空间上向量 得出 摄像机空间中x轴正方向/摄像机右向量/Right
    // 摄像机位置向量 = 摄像机位置向量 - 标量*摄像机空间x轴正向/世界空间x轴正向
    
    // 结果：摄像机朝向世界空间z轴反向，以(0, 0, 3)为起点，摄像机位置向量的x轴分量不断减小（同向）
    // lint：标准化设备坐标中，➡️为x轴正向，⬅️为x轴负向，⬆️为y轴正向，⬇️为y轴负向
    // 视觉上：摄像机向左移动
    cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
  }
  if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS){
    // 摄像机位置向量 = 摄像机位置向量 + 标量*摄像机空间x轴正向/世界空间x轴正向
    // 结果：摄像机朝向z轴负向，以(0, 0, 3)为起点，摄像机位置向量的x轴分量不断增大
    // 视觉上：摄像机向右移动
    cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
  }
}
```

横移 Strafe：本例中 A D 效果



## 小结

| 名词              | 摄像机空间          | 世界空间       | 屏幕 |
| ----------------- | ------------------- | -------------- | ---- |
| 摄像机位置向量    | 摄像机空间的原点    | 摄像机位置向量 |      |
| 摄像机方向向量    | 摄像机空间的z轴负向 |                |      |
| 摄像机右轴        | 摄像机空间的x轴正向 |                |      |
| 摄像机左轴        | 摄像机空间的y轴正向 |                |      |
| 世界空间的x轴正向 |                     |                | ➡️    |
| 世界空间的y轴正向 |                     |                | ⬆️    |



## 移动速度

调整 `cameraSpeed` 即可





